[{"content":"Contained in this GitHub repository are all of my solutions to Project Euler problems, and a simple CLI to run them. The rest of this post is copied straight from the repo\u0026rsquo;s README.\nI have tried to generalize these solutions somewhat, so they can be repurposed later. Each subdirectory of ans is numbered according to the problem it solves on Project Euler. Presently, I have only a few problems solved. If in the future this number grows, I will most likely fork this repository and make it private, leaving only the first 100 open for outside examination.\nStructure:  This is all under the Go module m9ple/euler. main accesses answers through the ans package, through the Sol(p int) and Ask(p int) functions, where p is the problem number. Each problem is contained in its own sub-package of ans, named p\u0026lt;number\u0026gt;. Example: The full name for the package that contains the solution for Problem 3 is m9ple/euler/ans/p3. To get the exact answer for Problem 3, call ans.Sol(3). To run the interactive session for Problem 3, call ans.Ask(3). Note: All of the $$ you see in problem READMEs is just unrendered LaTeX. GitHub does not currently support any easy method of rendering LaTeX. This is such a hotly demanded feature that I have to believe they will do so sometime relatively soon. As such, I\u0026rsquo;m not using any workarounds to display it anyway, because it\u0026rsquo;s too much work.   is a great workaround that I considered using, but decided against it. Codecogs is also a great resource, I just didn\u0026rsquo;t feel like it.    The euler CLI A utility used to run any solution, without having to travel to each solution\u0026rsquo;s directory and go run .\nI am very new to Go, so I\u0026rsquo;m still trying to figure out how to implement this. I\u0026rsquo;m literally just grabbing from two big map[int]func() (declared in probmap.go), where the index corresponds to the problem number. I have struggled trying to come up with a more elegant implementation, but right now I\u0026rsquo;m not sure what that would be.\nUsage: euler \u0026lt;p\u0026gt; - Run the solution for problem \u0026lt;p\u0026gt;. Directly outputs answer -i \u0026lt;p\u0026gt; - Run the interactive solution session for problem \u0026lt;p\u0026gt; -g - Open this repo at github.com/m9ple/euler -g \u0026lt;p\u0026gt; - Open the subdirectory for problem \u0026lt;p\u0026gt; on github. ","permalink":"https://heen.dev/project/euler/","summary":"Contained in this GitHub repository are all of my solutions to Project Euler problems, and a simple CLI to run them. The rest of this post is copied straight from the repo\u0026rsquo;s README.\nI have tried to generalize these solutions somewhat, so they can be repurposed later. Each subdirectory of ans is numbered according to the problem it solves on Project Euler. Presently, I have only a few problems solved. If in the future this number grows, I will most likely fork this repository and make it private, leaving only the first 100 open for outside examination.","title":"Euler"},{"content":"Question Original post on ProjectEuler.net\nEach new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:\n1, 2, 3, 5, 8, 13, 21, 34, 55, 89, \u0026hellip;\nBy considering the terms in the Fibonacci sequence whose values do not exceed 4,000,000, find the sum of the even-valued terms.\n Solution This problem is meant to teach the reader how to think of a recursive problem in an iterative fashion. Recursive solutions can be intellectually stimulating and syntactically elegant, but from my experience, a loop is often better suited to the task.\nBy understanding the base cases and the nature of the Fibonnaci sequence, you can implement this as an array that references earlier values as needed, as opposed to a recursive nightmare. By simply declaring the initial three values, I don\u0026rsquo;t even have to test for the special cases of the loop, which would have been the base cases of the recursive implementation.\n// Returns the sum of all even fibonacci numbers with values \u0026lt;= n func sumEvenFib(n int) (sum int) { \tsum = 0 \tvar fibs = []int{1, 1, 2} \tfor n := 2; fibs[n] \u0026lt;= limit; fibs = append(fibs, fibs[n-1]+fibs[n-2]) { \tif fibs[n]%2 == 0 { \tsum += fibs[n] \t} \t} \treturn sum }  Note: Tail recursion exists as a method for implementing certain algorithms and is essentially just as efficient as a loop, but I\u0026rsquo;m leaving it out because a tail-recursive solution involving function closures or global variables would be unnecessarily complicated.\n ","permalink":"https://heen.dev/writeup/euler/2/","summary":"Question Original post on ProjectEuler.net\nEach new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:\n1, 2, 3, 5, 8, 13, 21, 34, 55, 89, \u0026hellip;\nBy considering the terms in the Fibonacci sequence whose values do not exceed 4,000,000, find the sum of the even-valued terms.\n Solution This problem is meant to teach the reader how to think of a recursive problem in an iterative fashion.","title":"Even Fibonnacci Numbers"},{"content":"Question Original post on ProjectEuler.net\nIf we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6, 9. The sum of these multiples is 23.\nFind the sum of all the multiples of 3 or 5 below 1000.\n Solution This problem is essentially checking the exact same logic as Fizzbuzz, so I feel there isn\u0026rsquo;t much to be said about the fundamentals of the math and logic behind this.\nThe Go language, however, has a semantically convenient and syntactically beautiful way to implement this. Instead of writing cascading if {} else if {} else {} statements that get tedious and ugly, switch statements without arguments are used. A switch statement without an argument is the same as writing switch true, meaning it will evaluate each case in order until one evaluates to true. This allows me to write more readable code, while also bypassing any extraneous redundancy checking.\n// Returns the sum of all multiples of 3 and 5 below n. func sumThreeFive(n uint64) sum uint64 {  sum = 0 \tfor i := uint64(0); i \u0026lt; n; i++ { \tswitch { \tcase i%3 == 0: \tsum += i \tcase i%5 == 0: \tsum += i \t} \t} \treturn sum } ","permalink":"https://heen.dev/writeup/euler/1/","summary":"Question Original post on ProjectEuler.net\nIf we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6, 9. The sum of these multiples is 23.\nFind the sum of all the multiples of 3 or 5 below 1000.\n Solution This problem is essentially checking the exact same logic as Fizzbuzz, so I feel there isn\u0026rsquo;t much to be said about the fundamentals of the math and logic behind this.","title":"Multiples of 3 or 5"},{"content":"Empty (for now) There\u0026rsquo;s nothing here quite yet. Stay tuned, though!\n","permalink":"https://heen.dev/blog/","summary":"Empty (for now) There\u0026rsquo;s nothing here quite yet. Stay tuned, though!","title":"Blog"},{"content":"Just some sounds I\u0026rsquo;ve made trying to codify my thoughts and emotions.\n","permalink":"https://heen.dev/music/","summary":"music","title":"Music"}]