[{"content":" 1st place submission at Minnehack 2023, an annual hackathon at the University of Minnesota.\nBill Nom takes in a URL for a bill on the Minnesota Revisor\u0026rsquo;s Office website, scrapes the bill\u0026rsquo;s contents, digests it with a lightweight Natural Language Processing (NLP) model, and outputs a summary that\u0026rsquo;s easier for laypeople to grasp than the full text. The NLP model powering Bill Nom is small compared to many language models, at 230 MB, it can easily run under the memory and processing power limitations of a consumer-grade laptop.\nJust like any other machine learning model, Bill Nom should not be perceived as any sort of panacea for complex, real-world issues. However, my team and I believe that it serves as a valuable proof-of concept for a tool that can alleviate the task of digesting \u0026ldquo;legalese\u0026rdquo;; a task often quite daunting for the average citizen.\nStructure The model at the heart of it was produced with the T5 model from Google imported from Huggingface Our training data was obtained by scraping around a thousand documents from the MN Revisor\u0026rsquo;s Office website, using Beautiful Soup 4 (BS4). We used Pandas dataframes to process the raw JSON files produced by BS4. It was trained in a Jupyter notebook with PyTorch, which took approximately three hours to complete running on an Nvidia 3060 12GB. Front-end built using Dash by Plotly. API to access the back-end is just Python. Why People often struggle trying to parse common legal vernacular, often dubbed \u0026ldquo;legalese\u0026rdquo; as a result. As a written language, legalese occupies an odd niche of being both very formulaic and very lacking in any sort of natural flow. It can feel very reduntant to read, with only a few keywords changing between otherwise identical phrases. Sentences can stretch on for much longer than is normal for common english.\nThis ultimately leaves the reader confused, as they are attempting to digest something written in a format that was intended to be logistically robust when taken together as a single unit, not necessarily construct any sort of narrative for the reader\u0026rsquo;s internal dialogue to latch onto. All of this to say, reading and understanding legal documents is a very different skill than just reading common english.\nSource code github.com/eaheen/billnom\n","permalink":"https://heen.dev/project/billnom/","summary":"1st place submission at Minnehack 2023, an annual hackathon at the University of Minnesota.\nBill Nom takes in a URL for a bill on the Minnesota Revisor\u0026rsquo;s Office website, scrapes the bill\u0026rsquo;s contents, digests it with a lightweight Natural Language Processing (NLP) model, and outputs a summary that\u0026rsquo;s easier for laypeople to grasp than the full text. The NLP model powering Bill Nom is small compared to many language models, at 230 MB, it can easily run under the memory and processing power limitations of a consumer-grade laptop.","title":"Bill Nom"},{"content":"Contained in this GitHub repository are all of my solutions to Project Euler problems, and a simple CLI to run them. The rest of this post is copied straight from the repo\u0026rsquo;s README.\nI have tried to generalize these solutions somewhat, so they can be repurposed later. Each subdirectory of ans is numbered according to the problem it solves on Project Euler. Presently, I have only a few problems solved. If in the future this number grows, I will most likely fork this repository and make it private, leaving only the first 100 open for outside examination.\nStructure: This is all under the Go module m9ple/euler. main accesses answers through the ans package, through the Sol(p int) and Ask(p int) functions, where p is the problem number. Each problem is contained in its own sub-package of ans, named p\u0026lt;number\u0026gt;. Example: The full name for the package that contains the solution for Problem 3 is m9ple/euler/ans/p3. To get the exact answer for Problem 3, call ans.Sol(3). To run the interactive session for Problem 3, call ans.Ask(3). Note: All of the $$ you see in problem READMEs is just unrendered LaTeX. GitHub does not currently support any easy method of rendering LaTeX. This is such a hotly demanded feature that I have to believe they will do so sometime relatively soon. As such, I\u0026rsquo;m not using any workarounds to display it anyway, because it\u0026rsquo;s too much work. is a great workaround that I considered using, but decided against it. Codecogs is also a great resource, I just didn\u0026rsquo;t feel like it. The euler CLI A utility used to run any solution, without having to travel to each solution\u0026rsquo;s directory and go run .\nI am very new to Go, so I\u0026rsquo;m still trying to figure out how to implement this. I\u0026rsquo;m literally just grabbing from two big map[int]func() (declared in probmap.go), where the index corresponds to the problem number. I have struggled trying to come up with a more elegant implementation, but right now I\u0026rsquo;m not sure what that would be.\nUsage: euler \u0026lt;p\u0026gt; - Run the solution for problem \u0026lt;p\u0026gt;. Directly outputs answer -i \u0026lt;p\u0026gt; - Run the interactive solution session for problem \u0026lt;p\u0026gt; -g - Open this repo at github.com/m9ple/euler -g \u0026lt;p\u0026gt; - Open the subdirectory for problem \u0026lt;p\u0026gt; on github. ","permalink":"https://heen.dev/project/euler/","summary":"Contained in this GitHub repository are all of my solutions to Project Euler problems, and a simple CLI to run them. The rest of this post is copied straight from the repo\u0026rsquo;s README.\nI have tried to generalize these solutions somewhat, so they can be repurposed later. Each subdirectory of ans is numbered according to the problem it solves on Project Euler. Presently, I have only a few problems solved. If in the future this number grows, I will most likely fork this repository and make it private, leaving only the first 100 open for outside examination.","title":"Euler"},{"content":"Question Original post on ProjectEuler.net\nEach new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:\n1, 2, 3, 5, 8, 13, 21, 34, 55, 89, \u0026hellip;\nBy considering the terms in the Fibonacci sequence whose values do not exceed 4,000,000, find the sum of the even-valued terms.\nSolution This problem is meant to teach the reader how to think of a recursive problem in an iterative fashion. Recursive solutions can be intellectually stimulating and syntactically elegant, but from my experience, a loop is often better suited to the task.\nBy understanding the base cases and the nature of the Fibonnaci sequence, you can implement this as an array that references earlier values as needed, as opposed to a recursive nightmare. By simply declaring the initial three values, I don\u0026rsquo;t even have to test for the special cases of the loop, which would have been the base cases of the recursive implementation.\n// Returns the sum of all even fibonacci numbers with values \u0026lt;= n func sumEvenFib(n int) (sum int) { sum = 0 var fibs = []int{1, 1, 2} for n := 2; fibs[n] \u0026lt;= limit; fibs = append(fibs, fibs[n-1]+fibs[n-2]) { if fibs[n]%2 == 0 { sum += fibs[n] } } return sum } Note: Tail recursion exists as a method for implementing certain algorithms and is essentially just as efficient as a loop, but I\u0026rsquo;m leaving it out because a tail-recursive solution involving function closures or global variables would be unnecessarily complicated.\n","permalink":"https://heen.dev/writeup/euler/2/","summary":"Question Original post on ProjectEuler.net\nEach new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:\n1, 2, 3, 5, 8, 13, 21, 34, 55, 89, \u0026hellip;\nBy considering the terms in the Fibonacci sequence whose values do not exceed 4,000,000, find the sum of the even-valued terms.\nSolution This problem is meant to teach the reader how to think of a recursive problem in an iterative fashion.","title":"Even Fibonnacci Numbers"},{"content":"Question Original post on ProjectEuler.net\nIf we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6, 9. The sum of these multiples is 23.\nFind the sum of all the multiples of 3 or 5 below 1000.\nSolution This problem is essentially checking the exact same logic as Fizzbuzz, so I feel there isn\u0026rsquo;t much to be said about the fundamentals of the math and logic behind this.\nThe Go language, however, has a semantically convenient and syntactically beautiful way to implement this. Instead of writing cascading if {} else if {} else {} statements that get tedious and ugly, switch statements without arguments are used. A switch statement without an argument is the same as writing switch true, meaning it will evaluate each case in order until one evaluates to true. This allows me to write more readable code, while also bypassing any extraneous redundancy checking.\n// Returns the sum of all multiples of 3 and 5 below n. func sumThreeFive(n uint64) sum uint64 { sum = 0 for i := uint64(0); i \u0026lt; n; i++ { switch { case i%3 == 0: sum += i case i%5 == 0: sum += i } } return sum } ","permalink":"https://heen.dev/writeup/euler/1/","summary":"Question Original post on ProjectEuler.net\nIf we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6, 9. The sum of these multiples is 23.\nFind the sum of all the multiples of 3 or 5 below 1000.\nSolution This problem is essentially checking the exact same logic as Fizzbuzz, so I feel there isn\u0026rsquo;t much to be said about the fundamentals of the math and logic behind this.","title":"Multiples of 3 or 5"},{"content":"Just some sounds I\u0026rsquo;ve made trying to codify my thoughts and emotions.\n","permalink":"https://heen.dev/music/","summary":"music","title":"Music"}]