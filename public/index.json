[{"content":" 1st place submission at Minnehack 2023, an annual hackathon at the University of Minnesota.\nBill Nom takes in a URL for a bill on the Minnesota Revisor\u0026rsquo;s Office website, scrapes the bill\u0026rsquo;s contents, digests it with a lightweight Natural Language Processing (NLP) model, and outputs a summary that\u0026rsquo;s easier for laypeople to grasp than the full text. The NLP model powering Bill Nom is small compared to many language models, at 230 MB, it can easily run under the memory and processing power limitations of a consumer-grade laptop.\nJust like any other machine learning model, Bill Nom should not be perceived as any sort of panacea for complex, real-world issues. However, my team and I believe that it serves as a valuable proof-of concept for a tool that can alleviate the task of digesting \u0026ldquo;legalese\u0026rdquo;; a task often quite daunting for the average citizen.\nStructure The model at the heart of it was produced with the T5 model from Google imported from Huggingface Our training data was obtained by scraping around a thousand documents from the MN Revisor\u0026rsquo;s Office website, using Beautiful Soup 4 (BS4). We used Pandas dataframes to process the raw JSON files produced by BS4. It was trained in a Jupyter notebook with PyTorch, which took approximately three hours to complete running on an Nvidia 3060 12GB. Front-end built using Dash by Plotly. API to access the back-end is just Python. Why People often struggle trying to parse common legal vernacular, often dubbed \u0026ldquo;legalese\u0026rdquo; as a result. As a written language, legalese occupies an odd niche of being both very formulaic and very lacking in any sort of natural flow. It can feel very reduntant to read, with only a few keywords changing between otherwise identical phrases. Sentences can stretch on for much longer than is normal for common english.\nThis ultimately leaves the reader confused, as they are attempting to digest something written in a format that was intended to be logistically robust when taken together as a single unit, not necessarily construct any sort of narrative for the reader\u0026rsquo;s internal dialogue to latch onto. All of this to say, reading and understanding legal documents is a very different skill than just reading common english.\nSource code github.com/eaheen/billnom\n","permalink":"http://localhost:1313/project/billnom/","summary":"1st place submission at Minnehack 2023, an annual hackathon at the University of Minnesota.\nBill Nom takes in a URL for a bill on the Minnesota Revisor\u0026rsquo;s Office website, scrapes the bill\u0026rsquo;s contents, digests it with a lightweight Natural Language Processing (NLP) model, and outputs a summary that\u0026rsquo;s easier for laypeople to grasp than the full text. The NLP model powering Bill Nom is small compared to many language models, at 230 MB, it can easily run under the memory and processing power limitations of a consumer-grade laptop.","title":"Bill Nom"},{"content":"Question Original post on ProjectEuler.net\nEach new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:\n1, 2, 3, 5, 8, 13, 21, 34, 55, 89, \u0026hellip;\nBy considering the terms in the Fibonacci sequence whose values do not exceed 4,000,000, find the sum of the even-valued terms.\nSolution This problem is meant to teach the reader how to think of a recursive problem in an iterative fashion. Recursive solutions can be intellectually stimulating and syntactically elegant, but from my experience, a loop is often better suited to the task.\nBy understanding the base cases and the nature of the Fibonnaci sequence, you can implement this as an array that references earlier values as needed, as opposed to a recursive nightmare. By simply declaring the initial three values, I don\u0026rsquo;t even have to test for the special cases of the loop, which would have been the base cases of the recursive implementation.\n// Returns the sum of all even fibonacci numbers with values \u0026lt;= n func sumEvenFib(n int) (sum int) { sum = 0 var fibs = []int{1, 1, 2} for n := 2; fibs[n] \u0026lt;= limit; fibs = append(fibs, fibs[n-1]+fibs[n-2]) { if fibs[n]%2 == 0 { sum += fibs[n] } } return sum } Note: Tail recursion exists as a method for implementing certain algorithms and is essentially just as efficient as a loop, but I\u0026rsquo;m leaving it out because a tail-recursive solution involving function closures or global variables would be unnecessarily complicated.\n","permalink":"http://localhost:1313/writeup/euler/2/","summary":"Question Original post on ProjectEuler.net\nEach new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:\n1, 2, 3, 5, 8, 13, 21, 34, 55, 89, \u0026hellip;\nBy considering the terms in the Fibonacci sequence whose values do not exceed 4,000,000, find the sum of the even-valued terms.\nSolution This problem is meant to teach the reader how to think of a recursive problem in an iterative fashion.","title":"Even Fibonnacci Numbers"},{"content":"Question Original post on ProjectEuler.net\nIf we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6, 9. The sum of these multiples is 23.\nFind the sum of all the multiples of 3 or 5 below 1000.\nSolution This problem is essentially checking the exact same logic as Fizzbuzz, so I feel there isn\u0026rsquo;t much to be said about the fundamentals of the math and logic behind this.\nThe Go language, however, has a semantically convenient and syntactically beautiful way to implement this. Instead of writing cascading if {} else if {} else {} statements that get tedious and ugly, switch statements without arguments are used. A switch statement without an argument is the same as writing switch true, meaning it will evaluate each case in order until one evaluates to true. This allows me to write more readable code, while also bypassing any extraneous redundancy checking.\n// Returns the sum of all multiples of 3 and 5 below n. func sumThreeFive(n uint64) sum uint64 { sum = 0 for i := uint64(0); i \u0026lt; n; i++ { switch { case i%3 == 0: sum += i case i%5 == 0: sum += i } } return sum } ","permalink":"http://localhost:1313/writeup/euler/1/","summary":"Question Original post on ProjectEuler.net\nIf we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6, 9. The sum of these multiples is 23.\nFind the sum of all the multiples of 3 or 5 below 1000.\nSolution This problem is essentially checking the exact same logic as Fizzbuzz, so I feel there isn\u0026rsquo;t much to be said about the fundamentals of the math and logic behind this.","title":"Multiples of 3 or 5"},{"content":"Just some sounds I\u0026rsquo;ve made trying to codify my thoughts and emotions.\n","permalink":"http://localhost:1313/music/","summary":"music","title":"Music"},{"content":"Available upon request. Feel free to send me an email.\n","permalink":"http://localhost:1313/signal/","summary":"Available upon request. Feel free to send me an email.","title":"Signal"}]